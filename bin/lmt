#!/usr/bin/env ruby
# Encoding: utf-8

require 'optparse'
require 'methadone'

class App
  include Methadone::Main
  include Methadone::CLILogging

  @dev = true

  main do
    begin
      self_test()
      tangler = App::Tangler.new("src/lmt.lmd")
      tangler.tangle()
      tangler.write("bin/lmt")
    rescue Exception => e
      puts "Error: #{e.message} #{extract_causes(e)}At:"
      e.backtrace.each do |trace|
        puts "    #{trace}"
      end
    end
  end

  def self.extract_causes(error)
    if (error.cause)
      "  Caused by: #{error.cause.message}\n#{extract_causes(error.cause)}"
    else
      ""
    end
  end

  def self.self_test()
    block_replacement = true
    replaced_block = false
    block_appendment = false
    
    # this shouldn't be in the output, it should have been replaced.
    block_replacement = false
    # this is the replacement
    replaced_block = true
    # Yay appended code gets injected
    block_appendment = true
    insertion_works_with_spaces = false
    insertion_works_with_spaces = true
    escaped_string = '⦅macro_description⦆'
    # These require the code in the macro to work.
    report_self_test_failure("block replacement doesn't work") unless block_replacement and replaced_block
    report_self_test_failure("appending to macros doesn't work") unless block_appendment
    report_self_test_failure("insertion must support spaces") unless insertion_works_with_spaces
    report_self_test_failure("double parentheses may be escaped") unless escaped_string[0] != '\\'
    string_with_backslash = "this string ends in \."
    report_self_test_failure("ruby escape doesn't escape backslash") unless string_with_backslash =~ /\\.?/
  end

  def self.report_self_test_failure(message)
    if @dev
      p message
    else
      throw message
    end
  end

  class Tangler
    def initialize(input)
      @input = input
      @block = ""
      @blocks = {}
      @tangled = false
    end
    
    def tangle()
      contents = read_file()
      @block, @blocks = parse_blocks(contents)
      @block = expand_macros(@block)
      @block = unescape_double_parens(@block)
      @tangled = true
    end
    
    def read_file()
      #fin = File.open(@input, 'r')
      fin = File.open("src/lmt.lmd", 'r')
      last_header = nil
      fin.readlines
    end
    
    def parse_blocks(lines)
      code_block_exp = /^([s]*)``` ?[\w]* ?(=?)([-\w]*)?/
      in_block = false
      blocks = lines.find_all do |line|
        in_block = !in_block if line =~ code_block_exp
        in_block
      end.slice_before do |line|
        code_block_exp =~ line
      end.map do |(header, *rest)|
        match = code_block_exp.match(header)
        [match[3], rest]
      end.group_by do |(name, body)|
        name
      end.transform_values do |bodies|
        bodies.map { |(_, body)| body}
          .flatten(1)
      end.transform_values do |body_lines|
        body_lines[-1] = body_lines[-1].chomp if body_lines[-1]
        body_lines
      end
      throw "Missing code fence" if in_block
      main = blocks[""]
      blocks.delete("")
      [main, blocks]
    end
    
    def expand_macros(lines, depth = 0)
      throw "too deep macro expansion {depth}" if depth > 1000
      white_space_exp = /^(\s*)(.*\n?)/
      macro_substitution_exp = /(?<!\\)⦅ *([-\w | ]*) *⦆/
      filter_extraction_exp = / *\| *([-\w]+) */
      lines.map do |line|
        begin
          white_space, text = white_space_exp.match(line)[1..2]
          section = text.split(macro_substitution_exp)
              .each_slice(2)
              .map do |(before, macro_match)|
                if (macro_match)
                  macro_name, *filters = macro_match.strip.split(filter_extraction_exp)
                  [before, macro_name, filters.each_slice(2).map(&:first)]
                else
                  [before]
                end
              end.inject([white_space]) do
                |(*new_lines, last_line), (before, macro_name, filters)|
                if macro_name.nil?
                  new_lines << last_line + before
                else
                  throw "Macro '#{macro_name}' unknown" unless @blocks[macro_name]
                  macro_lines = apply_filters(
                      expand_macros(@blocks[macro_name], depth + 1), filters)
                  new_line = last_line + before + macro_lines[0]
                  macro_continued = macro_lines[1..-1].map do |macro_line|
                    white_space + macro_line
                  end
                  (new_lines << new_line) + macro_continued
                end
              end
        rescue Exception => e
          raise "Failed to process line: #{line}"
        end
      end.flatten(1)
    end
    
    def apply_filters(strings, filters)
      strings
    end
    def unescape_double_parens(block)
      block.map do |l|
        l = l.gsub("\\⦅", "⦅")
        l = l.gsub("\\⦆", "⦆")
        l
      end
    end
    
    def write(output)
      fout = File.open(output, 'w')
      tangle() unless @tangled
      @block.each {|line| fout << line}
    end
    
  end

  description "A literate markdown tangle tool written in Ruby."
  on("--file FILE", "-f", "input file")
  on("--output FILE", "-o", "output file")
  on("--dev", "disables self test failure for development")
  # TODO: required arguments
  #arg :file
  #arg :output

  version Lmt::VERSION

  use_log_level_option :toggle_debug_on_signal => 'USR1'

  go! if __FILE__ == $0
end
