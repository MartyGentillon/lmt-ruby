#!/usr/bin/env ruby
# Encoding: utf-8

require 'optparse'
require 'methadone'
require 'lmt.rb'
require 'fileutils'


class App
  include Methadone::Main
  include Methadone::CLILogging

  #  This is a comment
  # this is actually a comment
  # more comments


  main do # Add args you want: |like,so|
    # your program code here
    # You can access CLI options via
    # the options Hash
    begin
      tangler = App::Tangler.new("src/lmt.lmd")
      tangler.tangle()
      tangler.write("bin/lmt")

    rescue Exception => e
      puts "Error: #{e.message} At:"
      e.backtrace.each do |trace|
        puts "    #{trace}"
      end
    end
  end

  class Tangler
    def initialize(input)
      @in_block = false
      @block = ""
      @blocks = {}
      @tangled = false
      @input = input
    end
  
    def tangle()
      contents = read_file_lines()
      @block, @blocks = parse_blocks(contents)
      @block = expand_macro(@block)
      @tangled = true
    end
  
    def read_file_lines()
      #fin = File.open(@input, 'r')
      fin = File.open("src/lmt.lmd", 'r')
      last_header = nil
      fin.readlines
    end
  
    def parse_blocks(lines)
      code_block_exp = /^[s]*``` ?[\w]* ?(=?)([-\w]*)?/
      blocks = lines.find_all do |line|
        b = @in_block
        @in_block = !@in_block if line =~ code_block_exp
        @in_block
      end.slice_before do |line|
        code_block_exp =~ line
      end.map do |(header, *rest)|
        match = code_block_exp.match(header)
        [match[2], rest]
      end.group_by do |(header, body)|
        header
      end.transform_values do |bodies|
        bodies.map { |(_, body)| body}.flatten(1)
      end
      main = blocks[""]
      blocks.delete("")
      [main, blocks]
    end
  
    def expand_macro(lines, depth = 0)
      throw "too deep macro expansion {depth}" if depth > 1000
      white_space_exp = /^(\s*)(.*\n?)/
      macro_substitution_exp = /⦅([-\w]*)⦆/
      lines.map do |line|
        white_space, text = white_space_exp.match(line)[1..2]
        section = text.split(macro_substitution_exp)
          .each_slice(2)
          .inject([white_space]) do
            |(*new_lines, last_line), (before, macro_name)|
            if macro_name.nil?
              new_lines << last_line + before
            else
              throw "Macro #{macro_name} unknown" unless @blocks[macro_name]
              macro_lines = expand_macro(@blocks[macro_name], depth + 1)
              new_line = last_line + before + macro_lines[0]
              macro_continued = macro_lines[1..-1].map do |macro_line|
                white_space + macro_line
              end
              (new_lines << new_line) + macro_continued
            end
          end
      end.flatten(1)
    end
  
    def write(output)
      fout = File.open(output, 'w')
      tangle() unless @tangled
      @block.each {|line| fout << line}
    end
  end


  # supplemental methods here

  # Declare command-line interface here

  # description "one line description of your app"
  #
  # Accept flags via:
  # on("--flag VAL","Some flag")
  # options[flag] will contain VAL
  #
  # Specify switches via:
  # on("--[no-]switch","Some switch")
  #
  # Or, just call OptionParser methods on opts
  #
  # Require an argument
  # arg :some_arg 
  #
  # # Make an argument optional
  # arg :optional_arg, :optional

  version Lmt::VERSION

  use_log_level_option :toggle_debug_on_signal => 'USR1'

  go! if __FILE__ == $0
end
