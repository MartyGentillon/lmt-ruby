# Lmt-Ruby

Lmt is a literate markdown tangle program for [literate programing](https://en.wikipedia.org/wiki/Literate_programming) in a slightly extended [Markdown](http://daringfireball.net/projects/markdown/syntax) syntax that is written in Ruby.

In literate programming, a program is contained within a prose essay describing the thinking which goes into the program.  The source code is then extracted from the essay using a program called tangle (this application).  The essay can also be formatted into a document for human consumption using a program called "weave".

## Why?

While there are other markdown tanglers available (especially [lmt](https://github.com/driusan/lmt), which this program is designed to be superficially similar to) none quite match the combination of simplicity and extensibility which I need.

## Features

In order to be useful for literate programming we need a few features:

1. The ability to strip code out of a markdown file and place it into a tangled file with either a default or specified name.
2. The ability to embed macros so that the code can be expressed in any order desired.
3. The ability to apply filters on the contents of a macro
4. The ability to to identify code blocks which will be expanded when referenced
5. The ability to append to or replace code blocks
6. The ability to extend the tangler with Ruby code from a block.

Markdown already supports code blocks expressed with code fences starting with three backticks, usually enabling syntax highlighting on the output.  This works for blocks that contain code.  Markdown also includes an off-left rule for defining block quotes.  This should be sufficient for english text.

In order to add the features we need, we will need to add header content at the beginning of such a quote. For code blocks, we can add it after the language name.  For example

```ruby comment
# This is a comment
```

For block quotes, well <<<TODO>>>.

Of course, these do not play well with markdown rendering, so we will need a weaver to display the name appropriately.

To replace a block put `=` before the block name like so:

```ruby =comment
# this is actually a comment
```

To append to a block, just open it again.  The macro expansion only happens after the entire file is read.

```ruby comment
# more comments
```

We will also need a way to trigger macro insertion.  Given that unicode tends not to be in use, why don't we say that anything inside ⦅⦆ refers to a block by name and should be replaced by the contents of that block.

Of course, we will also need a testing procedure.  Since this is written as a literate program, our test procedure is: can we tangle ourself.  If the output of the tangler run on this file can tangle this file, then we know that the tangler works.

## Implementation and Example

Now for an example.  Using Ruby we can write a template as below:

```ruby
#!/usr/bin/env ruby
# Encoding: utf-8

⦅includes⦆

class App
  include Methadone::Main
  include Methadone::CLILogging

  ⦅comment⦆

  main do # Add args you want: |like,so|
    # your program code here
    # You can access CLI options via
    # the options Hash
    begin
      ⦅tangle_routine⦆
    rescue Exception => e
      puts "Error: #{e.message} At:"
      e.backtrace.each do |trace|
        puts "    #{trace}"
      end
    end
  end

  ⦅tangle_class⦆

  # supplemental methods here

  # Declare command-line interface here

  # description "one line description of your app"
  #
  # Accept flags via:
  # on("--flag VAL","Some flag")
  # options[flag] will contain VAL
  #
  # Specify switches via:
  # on("--[no-]switch","Some switch")
  #
  # Or, just call OptionParser methods on opts
  #
  # Require an argument
  # arg :some_arg 
  #
  # # Make an argument optional
  # arg :optional_arg, :optional

  version Lmt::VERSION

  use_log_level_option :toggle_debug_on_signal => 'USR1'

  go! if __FILE__ == $0
end
```

``` ruby tangle_routine
tangler = App::Tangler.new("src/lmt.lmd")
tangler.tangle()
tangler.write("bin/lmt")
```

``` ruby includes
require 'optparse'
require 'methadone'
require 'lmt.rb'
require 'fileutils'
```

``` ruby tangle_class
class Tangler
  def initialize(input)
    @in_block = false
    @block = ""
    @blocks = {}
    @tangled = false
    @input = input
  end

  def tangle()
    contents = read_file_lines()
    @block, @blocks = parse_blocks(contents)
    @block = expand_macro(@block)
    @tangled = true
  end

  def read_file_lines()
    #fin = File.open(@input, 'r')
    fin = File.open("src/lmt.lmd", 'r')
    last_header = nil
    fin.readlines
  end

  def parse_blocks(lines)
    code_block_exp = /^[s]*``` ?[\w]* ?(=?)([-\w]*)?/
    blocks = lines.find_all do |line|
      b = @in_block
      @in_block = !@in_block if line =~ code_block_exp
      @in_block
    end.slice_before do |line|
      code_block_exp =~ line
    end.map do |(header, *rest)|
      match = code_block_exp.match(header)
      [match[2], rest]
    end.group_by do |(header, body)|
      header
    end.transform_values do |bodies|
      bodies.map { |(_, body)| body}.flatten(1)
    end
    main = blocks[""]
    blocks.delete("")
    [main, blocks]
  end

  def expand_macro(lines, depth = 0)
    throw "too deep macro expansion {depth}" if depth > 1000
    white_space_exp = /^(\s*)(.*\n?)/
    macro_substitution_exp = /⦅([-\w]*)⦆/
    lines.map do |line|
      white_space, text = white_space_exp.match(line)[1..2]
      section = text.split(macro_substitution_exp)
        .each_slice(2)
        .inject([white_space]) do
          |(*new_lines, last_line), (before, macro_name)|
          if macro_name.nil?
            new_lines << last_line + before
          else
            throw "Macro #{macro_name} unknown" unless @blocks[macro_name]
            macro_lines = expand_macro(@blocks[macro_name], depth + 1)
            new_line = last_line + before + macro_lines[0]
            macro_continued = macro_lines[1..-1].map do |macro_line|
              white_space + macro_line
            end
            (new_lines << new_line) + macro_continued
          end
        end
    end.flatten(1)
  end

  def write(output)
    fout = File.open(output, 'w')
    tangle() unless @tangled
    @block.each {|line| fout << line}
  end
end
```
